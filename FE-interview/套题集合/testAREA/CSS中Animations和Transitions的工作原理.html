<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>CSS中Animations和Transitions的工作原理</title>
</head>
<body>
<pre style="background:#eee;font-size:20px;">
浏览器的内部工作
让我们了解一些浏览器的工作原理，一探究竟。一旦我们了解了浏览器是如何工作的，我们就可以更好的去驾驭它。
现代浏览器通常拥有两个重要的执行线程，这两个线程相互配合来渲染出页面：
    主线程
    排版线程
通常情况下，主线程主要负责以下工作：
    运行JavaScript
    计算HTML元素的CSS样式
    布局页面
    把页面元素绘制成一个或多个位图
    把这些位图移交给排版线程
通常情况下，排版线程主要负责以下工作：
    通过GPU渲染位图，并显示在屏幕上
    向主线程请求更新位图的可见部分或即将可见的部分
    判断出当前页面处于可见的部分
    判断出即将通过页面滚动而可见的部分
    随着用户滚动页面来移动这些部分（译者注：可见部分的和即将可见的部分）

当长时间运行JavaScript或渲染一个很多的元素时，主线程会一直处于忙碌状态。在这期间它不会对用户的输入做出任何反应。
在另一方面，排版线程对用户输入保持着非常快的响应。当页面变化时，排版线程尝试以每秒60帧的速度去重绘页面，即便这时页面还不完整。
举例来说，当用户滚动页面时，排版线程向主线程请求更新页面新显示部分的位图，但是，如果此时主线程并不能迅速响应请求，排版线程并不会去等待响应，它会用它目前所拥有的这部分页面的内容去渲染页面，由于对应的内容还没有，所以会以白板的形式渲染出来。
GPU
我前边提到过排版线程通过GPU把位图绘制到了屏幕上。让我们快速的过一下GPU相关的东西。
GPU是一种芯片，在今天的大多数手机，平板以及电脑中都能发现它的身影。它是非常专业的，这意味着GPU在某些方面非常擅长，但是在另外一些方面去表现不好。
GPU比较擅长于：
    绘制位图到屏幕
    重复的绘制同一个位图
    在不同的位置，以不同的旋转角度，或者不同的缩放大小来绘制同一个位图。
GPU相对慢的地方：
    将位图加载到显存里。
  
 ===================================================================
 在整个Transition的每一帧中，浏览器都要去重新布局，绘制页面，并把最新的位图对象加载到GPU。我们前边了解过，把位图对象加载到GPU的内存中是个相对缓慢的操作。
浏览器之所以要在每一帧动画上处理如此繁重的工作是因为这个元素的内容一直在变化。修改一个元素的高度可能会引起其子元素也要相应的改变大小，因此浏览器必须去重新布局。重新布局后，主线程必须为该元素重新生成位图对象。

根据定义，CSS的transform属性不会改变元素的布局，也不会影响到其周围的元素。它把元素当做一个整体看待——缩放整个元素、旋转整个元素或者移动整个元素。
这对浏览器来说是一个好消息！浏览器只需在动画开始的时候生成这个元素的位图对象，并把它传递给GPU。在这之后，浏览器无需再做任何重新布局，绘制页面以及传递位图对象的操作了，相反，浏览器可以利用GPU擅长的绘制的特点来快速的在不同的位置，旋转或缩放同一个位图对象。

 	
</pre>	
</body>
</html>