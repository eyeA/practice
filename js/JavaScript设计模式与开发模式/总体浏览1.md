####  JavaScript中的原型继承
  1.JavaScript中的根对象是Object.prototype对象。是一个空对象。
  2.要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它。
  3.对象会记住它的原型。
  4.如果对象无法响应某个请求，它会把这个请求委托给它的构造器的原型。

### this call apply
  1.this的指向：
    1.作为对象的方法调用；
    2.作为普通函数调用；在函数局部有个方法，该方法作为普通函数调用时候，其内部的this指向了window--> 把this初始给一个变量保存；
    3.构造器调用；JavaScript没有类，但是可以从构造器中创建对象，同时也提供了new运算符。注意：如果构造器显示的返回了一个object类型的对象，
    那么此次运算结果会最终返回这个对象，而不是我们期待的this；
    4.Function.prototype.call和Function.prototype.apply;可以动态的改变传入函数的this；
    5.call 和 apply ： 作用一模一样，区别仅在于传入的参数形式不同。
       apply接受两个参数，第一个参数指定了函数体内的this对象的指向，第二个参数为一个带下标的集合，这个集合可以是数组，也可以是伪数组。apply方法把这个集合中的元素作为参数传递给被调用的函数。
       call传入的参数数量不固定，第一个参数也是代表函数体内的this指向，第二个参数开始往后，每个参数被依次传入函数。
       当使用call和apply的时候，如果我们传入的第一个参数为null，函数体内的this会指向默认的宿主对象，在浏览器中则是window。
       Array.prototype.push.call(a,'first'); arguments --> 伪数组
### 闭包和高阶函数
  1.闭包的形成与变量的作用域以及变量的生存周期密切相关。
  2.利用闭包的例子：
    1.封装变量，缓存结果(Memoization) 下面的例子不很好。
        var cache = {},
        var mult = function(){
          var args = Array.prototype.join.call(arguments,',');
          if(cache[args]){
            return cache[args];
          };
          var a = 1;
          for(var i=0,len = arguments.length;i<len;i++){
            a = a * argument[i];
          };
          return cache[argus] = a;
        };
        alert(mult(1,2,3));  // 6
    2.
       var Tv = {  // 函数对象
         open: function(){
           console.log('打开电视机')
         },
         close: function(){
           console.log('关闭电视机')
         }
       };

       var createCommand = function(receiver){
         var execute = function(){
           return receiver.open();
         };
         var undo = function(){
           return receiver.close();
         };
         return {  // notice
           execute: execute,
           undo: undo
         };
       };

       var setCommand = function(command){
         a.onclick = function(){
           command.execute();  // 打开电视机
         };
         b.onclick = function(){
           command.undo();    // 关闭电视机
         }
       };

       setCommand(createCommand(Tv));

    3.判断返回数据的类型
      var isType = function(type){
        return function(obj){
          return Object.prototype.toString.call(obj) === '[object' + type + ']';
        }
      };

      var isString = isType('string');  // true
   4.AOP编程(面向切面编程)的主要作用就是把一些跟核心业务逻辑模块无关的功能抽离处理，这些跟业务逻辑无关的功能通常包括日志统计，
     安全控制，异常处理等；
     1.在JavaScript中实现AOP，都是指把一个函数'动态织入'到另外一个函数之中，很多方法，比如通过Function.prototype来做到：
     Function.prototype.before = function(beforefn){
       var \_self = this;  // 保存原函数的引用
       return function(){  // 返回包含了原函数和新函数的‘代理’函数
         beforefn.apply(this,arguments);  // 执行新函数，修正this
         return \_this.apply(this,arguments);  // 执行原函数
       }

     }
