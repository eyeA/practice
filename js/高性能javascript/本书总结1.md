> [来自这个链接](https://segmentfault.com/a/1190000003908314)

##### 第一章：减少javascript对性能的影响：
* `</body>` 闭合标签之前，将所有的 `<script>` 标签放到页面底部。这能确保在脚本执行前页面已经完成了渲染。不然 script 标签会阻塞页面的渲染。
  * 多数浏览器使用单一线程来处理用户界面UI刷新和JavaScript脚本执行，同一时刻只能做一件事；
  * 同样的情况也发生在 `src` ||  `script` 标签
* 合并脚本。页面中的 script 标签越少，加载也就越快，响应也更迅速。无论外链文件还是内嵌脚本都是如此。因为每一次 script 外部文件都会有一次HTTP请求
  * 允许多个js文件并行下载，但是同样会阻塞其他资源的下载；
  * 考虑到 HTTP 请求会带来额外的性能开销，因此下载单个100k的文件比下载4个25k的文件更快，也就是说，减少页面外链脚本文件的数量将会改善性能
  * __减少JavaScript文件大小并限制HTTP请求数；__
* 有多种无阻塞下载javascript的方法
  * 使用defer属性
    * defer属性指明本元素所含的脚本不会修改DOM，因此代码能够安全的延迟执行，目前浏览器都支持该属性，
    * async也是用于异步加载脚本，跟defer相同点事采用并行下载，在下载过程中不会产生阻塞，区别在于执行时机，async是在加载完成后自动执行，而defer需要等待页面完成后(__DOM加载完成，`onload`事件被触发前__)执行；
  * 动态脚本元素，即使用动态创建的 script 元素来下载并执行代码。
    * 需要跟踪并确保脚本下载完成且准备就绪 ObjectScript.onload = function(){},需要和 IE 兼容--> 是最通用的无阻塞加载解决方案；
  * 使用XHR对象下载javascript代码并注入页面中
  * __推荐的无阻塞模式__--> 向页面添加大量的js推荐做法两步：
    * 先添加动态加载所需要的代码，然后加载初始化页面所需的剩下的代码。因为第一部分尽量精简，甚至可能只包含loadScript()函数
    ```javascript
    <script type='text/javascript' src='loader.js'></script>
    <script type='text/javascript'>
      loadScript('the-rest.js',function(){
        Application.init();
      })
    </script>
    ```
    * 另外一种是把loadScript()函数直接嵌入假面，从而避免多产生一次HTTP请求。
    ```javascript
    <script type='text/javascript'>
      function loadScript(url,callback){
        var script = document.createElement('script');
        script.type= 'text/javascript';

        if(script.readyState){  //IE
          script.onreadystatechange = function(){
            if(script.readyState == 'loaded' || script.readyState == 'complete'){
              script.onreadystatechange = null;
              callback();
            }
          };
        }else{  //其他浏览器
          script.onload = function(){
            callback();
          };
        };
        script.src = url;
        document.getElementByTagName('head')[0].appendChild(script);
      };

      loadScript('the-rest.js',function(){
        Application.init();
      });

    </script>
    ```

##### 第二章：数据访问
  * 对象成员的嵌套也会开销系统资源。`location.href`永远会比`window.location.href`快。
  * 访问直接量和局部变量的速度最快，相反，访问数组元素和对象成员相对较慢。
  * 由于局部变量存在于作用域链的起始位置，因此访问局部变量比访问跨作用域变量更快。变量在作用域链中的位置越深，访问所需时间就越长。由于全局变量总处在作用域链的最末端，因此访问速度也是最慢的。
    * 每个JavaScript函数都表示为一个对象，更确切地说，是Function对象的一个实例。Function对象同其他对象一样，拥有可以编程访问的属性，和一系列不能通过代码访问而仅供JavaScript引擎存取的内部属性。
    * 内部属性 [[scope]] 包含了一个函数被创建的作用域中对象的集合，__Page(17,18)__
    * 在函数执行过程中，每遇到一个变量，都会经历一次标识符解析过程以决定从哪里获取或者存储数据。该过程搜索执行环境的作用域链，查找同名的标识符。搜索过程从当前运行函数的活动对象开始。--> 正是这个搜索过程影响了性能。
    * 一个标识符所在的位置越深，它的读写速度也就越慢，请记住，__全局变量__ 总是存在于执行环境作用域链的最末端。
    * 如果某个跨作用域的值在函数中被引用了一次以上，应当存储在局部变量里，比如document..
  * 避免使用with语句，因为它会改变运行期上下文作用域链。同样，try-catch语句中的catch子句也有同样的影响，因此要小心使用。
  * 嵌套的对象成员会明显影响性能，尽量少用
  * 属性或方法在原型链中的位置越深，访问它的速度也越慢。
  * 局部通常来说，你可以通过把常用的对象成员、数组元素、跨域变量保存在变量中来改善javascript的性能，因为局部变量访问速度最快。
  * 闭包允许函数访问局部作用域链之外的数据。
    * 闭包的副作用是因为：它包含了与执行环境相同的对象的引用；
    * 通常来说，函数的活动对象会随着执行环境一同销毁。但引入闭包后，由于引用仍然存在于闭包的[[scope]]属性中，因此激活的对象无法被销毁。
    * 这意味着脚本中的闭包与非闭包函数相比，需要更多的内存开销。
    * 将常用的跨作用域变量存储在局部变量中，然后直接访问局部变量。
  * __JavaScript的对象是基于原型的。原型是其他对象的基础，它定义了实现一个新创建的对象所必须包含的成员列表。__ 原型对象为所有的对象实例所共享，因此这些实例也共享了原型对象的成员。
    * 对象通过一个内部属性绑定到他的原型，这个属性是 \ ____proto__\__，对开发者可见。
    * 因此，对象可以有两种成员类型：``实例成员``和``原型成员``,实例成员直接存在于对象实例中，原型成员则从对象原型继承过来。
    * 用hasOwnProperty()方法来判断对象是否包含特定的实例成员(传递给方法的参数名，即成员的名称)
    * 要确定对象是否包含特定的属性，可以用 `in`操作符 --> 'title' in book;但是in是不能确定是原型成员还是实例成员的，因为它既会搜索实例也会搜索原型。
    * 局部变量能用来代替属性以避免多次超找带来的性能开销。
    * 同时要注意，许多对象方法使用`this`来判断执行环境，把一个对象方法保存在局部变量会导致`this`绑定到`window`，而`this`值的改变会使得JavaScript引擎无法正确解析他的对象成员，出错。

##### 第三章：DOM编程
* 浏览器通常会把DOM和JavaScript__独立实现__，两个相互独立的功能只要通过接口彼此链接，就会产生消耗；ECMAScript每次访问DOM,访问次数愈多，消耗越高，尽可能的减少访问次数，尽可能的在JavaScript处理。
  * 类数组并不是真正的数组，因为没有push或者slice之类的方法，但提供了一个类似数组中的length属性，并且还能以数字索引访问列表中的元素。
  * 读取一个集合的length比读取普通数组的length要慢很多，可以先将集合元素拷贝到数组中，那么访问他的属性会更快，但这会因额外的步骤带来消耗，而且会多遍历一次集合。
* 最小化DOM访问次数，尽可能在javascript端处理
* 如果需要多次访问某个DOM节点，请使用局部变量存储它的引用
* 小心处理HTML集合，因为它实时联系着底层文档。把集合的长度缓存到一个变量中，并在迭代中使用它。如果需要经常操作集合，建议把它拷贝到一个数组中。
* 如果可能的话，使用速度更快的API，__P48(top)__ 比如`querySelectorAll()` `firstElementChild()` `children` `childElementCount`
* 要留意重绘和重排；批量修改样式时，“离线”操作DOM树，使用缓存，并减少访问布局信息的次数。
  * 重绘repaint不一定重排，取决于元素的布局是否改变；
  * 但是重排一定发生重绘，因为重排就是浏览器使渲染树__受到影响__部分失效，重新构造渲染树 reflow
  * 获取布局信息的操作会导致队列刷新-->浏览器执行渲染队列中的‘待处理变化’，并触发重排以返回正确的值。这样P51重排发生的条件，获取信息不会发生repaint。
  * 每次重排都会产生计算消耗；
* 动画中使用绝对定位，使用拖放代理
* 使用事件委托来减少事件处理器的数量

##### 第四章：算法和流程控制
for、while和do-while循环性能相似，所以没有一种循环类型明显快于或慢于其他类型
避免使用for-in循环，除非你需要遍历一个属性数量未知的对象
改善循环性能的最佳方式是减少每次迭代的运算量和减少循环迭代次数
通常来说，switch总是比if-else快，但并不总是最佳解决方案
在判断条件较多时，使用查找表比if-else和switch更快
浏览器的调用栈大小限制了递归算法在javascript中的应用；栈溢出错误会导致其他代码中断运行
如果你遇到栈溢出错误，可将方法改为迭代算法，或使用Memoization来避免重复计算。

##### 第五章：字符串和正则表达式
当连接数量巨大或尺寸巨大的字符串时，数组项连接是唯一在IE7及更早版本中性能合理的方法
如果不考虑IE7及更早版本的性能，数组项连接是最慢的字符串连接方法之一。推荐使用简单的+和+=操作符替代，避免不必要的中间字符串
回溯既是正则表达式匹配功能的基本组成部分，也是正则表达式的低效之源
回溯失控发生在正则表达式本应该快速匹配的地方，但因为某些特殊的字符串匹配动作导致运行缓慢甚至浏览器崩溃。避免这个问题的办法是：使相邻的字元互斥，避免嵌套量词对同一字符串的相同部分多次匹配，通过重复利用向前查看的原子组去除不必要的回溯
提高正则表达式效率的各种技术手段会有助于正则表达式更快地匹配，并在非匹配位置上花更少的时间
正则表达式并不总是完成工作的最佳工具，尤其当你只搜索字面字符串的时候
尽管有许多方法可以去除字符串的首尾空白，但使用两个简单的正则表达式（一个用来去除头部空白，另一个用于去除尾部空白）来处理大量字符串内容能提供一个简洁而跨浏览器的方法。从字符串末尾开始循环向前搜索第一个非空白字符，或者将此技术同正则表达式结合起来，会提供一个更好的替代方案，它很少受到字符串长度的影响

##### 第六章：快速响应的用户界面
任何javascript任务都不应当执行超过100毫秒。过长的运行时间会导致UI更新出现明显的延迟，从而对用户体验产生负面的影响。
javascript运行期间，浏览器响应用户交互的行为存在差异。无论如何，javascript长时间运行将导致用户体验变得混乱和脱节
定时器可用来安排代码延迟执行，它使得你可以把长时间运行的脚本分解成一系列的小任务
Web workers是新版浏览器支持的特性，它允许你在UI线程外部执行javascript代码，从而避免锁定UI

##### 第七章：Ajax
作为数据格式，纯文本和HTML只适用于特定场合，但它们可以节省客户端的CPU周期。XML被广泛应用而且支持良好，但是它十分笨重且解析缓慢。JSON是轻量级的，解析速度快（被视为原生代码而不是字符串），通用性与XML相当。字符分隔的自定义格式十分轻量，在解析大量数据集时非常快，但需要编写额外的服务端构造程序，并在客户端解析。
当从页面当前所处的域下请求数据时，XHR提供了最完善的控制和灵活性，尽管它会把接收到的所有数据当成一个字符串，且这有可能降低解析速度。另一方面，动态脚本注入允许跨域请求和本地执行javascript和JSON但是它的接口不那么安全，而且还不能读取头信息或相应代码。Multipart XHR可以用来减少请求数，并处理一个响应中的各种文件类型，但是它不能缓存接收到的响应。当需要发送数据时，图片信标是一种简单而有效的方法。XHR还可以用POST方法发送大量数据。
除了这些格式和传输技术，还有一些准则有助于加速你的Ajax
减少请求数，可通过合并javascript和CSS文件，或使用MXHR
缩短页面的加载时间，页面主要内容加载完成后，用Ajax获取那些次要的文件
确保你的代码错误不会输出给用户，并在服务端处理错误
指导何时使用成熟的Ajax类库，以及何时编写自己的底层Ajax代码

##### 第八章：编程实践
通过避免使用eval()和Function()构造器来避免双重求值带来的性能消耗。同样的，给setTimeout()和setInterval()传递函数而不是字符串作为参数
尽量使用直接量创建对象和数组。直接量的创建和初始化都比非直接量形式要快
避免做重复的工作。当需要检测浏览器时，可使用延迟加载或条件预加载
在进行数学计算时，考虑使用直接操作数字的二进制形式的位运算
javascript的原生方法总会比你写的任何代码都要快。尽量使用原生的方法

##### 第九章：构建并部署高性能javascript应用
合并javascript文件以减少HTTP请求数
使用YUN Compressor压缩javascript文件
在服务器端压缩javascript文件（Gzip编码）
通过正确设置HTTP响应头来缓存javascript文件，通过向文件名增加时间戳来避免缓存问题
使用CDN提供javascript文件，CDN不仅可以提升性能，它也为你管理文件的压缩与缓存

##### 第十章：工具（截稿时期是2010年）
使用网络分析工具找出加载脚本和页面中其他资源的瓶颈，这回帮助你决定哪些脚本需要加载延迟，或者需要进一步分析
尽管传统的经验告诉我们要尽量减少HTTP请求数，但把脚本尽可能延迟加载可以加快页面渲染速度，给用户带来更好的体验
使用性能分析工具照吃脚本运行过程中速度慢得地方，检查每个函数所消耗的时间，以及函数被调用次数，通过调用栈自身提供的一些线索来找出需要集中精力优化的地方
尽管耗费的时间和条用次数通常是数据中最有价值的部分，但仔细观察函数的调用过程，你也许会发现其他优化目标
