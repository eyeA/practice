<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>字符串和正则表达式</title>
</head>
<body>
  处理大量的类似合并、分割、重新排序、搜索、遍历等字符串操作。
  正则表达式工作原理：
  第一步：编译；
  第二步：设置起始位置；
  第三步：匹配每个正则表达式字元；
  第四步：匹配成功或者失败；
<h2>2月4号</h2>
<a href="http://blog.csdn.net/jbjwpzyl3611421/article/details/20900101">参考博客(编译部分以后比较懵逼)</a>
正则表达式可以用来：
1.验证字符串是否符合指定的特征，比如验证邮箱；
2.查找字符串；
3.用来替换；

两种方式：
1.文字常量：  var re = /^[Jj]ava[Ss]cript/i;
2.使用RegExp构造函数:  var re = new RegExp('^[Jj]ava[Ss]cript','i');

解析器组成： 解析（parse）  --> 编译（compile）--> 执行（execute）；
1.解析（parse）：
A）普通字符和元字符

普通字符是那些表示自身的字符，例如从a到z，A到Z，0到9等；

元字符具有特殊意义，如‘.’，表示除了‘/n’外的所有字符，其他具有此功能的有



表1 元字符

元字符

特殊意义

^

匹配输入字符串的开始位置。要匹配 "^" 字符本身，请使用 "/^"

$

匹配输入字符串的结尾位置。要匹配 "$" 字符本身，请使用 "/$"

.

匹配除了换行符（/n）以外的任意一个字符。要匹配小数点本身，请使用 "/."

*

修饰匹配次数为 0 次或任意次。要匹配 "*" 字符本身，请使用 "/*"

+

修饰匹配次数为至少 1 次。要匹配 “+” 字符本身，请使用 “/+”

?

修饰匹配次数为 0 次或 1 次。要匹配 “?” 字符本身，请使用 “/?”

=

用于前向引用或向后引用

!

用于前向引用或向后引用

:

用于前向引用或向后引用

|

用于前向引用或向后引用

/

转义用

/

用于前向引用或向后引用

()

标记一个子表达式的开始和结束位置。要匹配小括号，请使用 “/(“ 和 “/)”

[]

用来自定义能够匹配 ‘多种字符’ 的表达式。要匹配中括号，请使用 “/[“ 和 “/]”

{}

修饰匹配次数的符号。要匹配大括号，请使用 “/{“ 和 “/}”

元数据如要表示自身，那么需要用’/’来辅助转义



B）字符类

单个的字符可以组成字符类，其语法为用’[’与’]’组成，例如[abcA-Z79]表示可以匹配a，b，c与A到Z，7，9的字符

其中’-’为连字符，表示字符的跨度。

‘^’在”[]”间也是特殊字符，表示取反

其他的特殊字符如下表：

表2 字符类中的预定义字符类

预定义字符类

特殊意义

^

在紧跟’[’表示取反，表示自身要转义

-

在字符间，表示连字符，如要表示自身，须紧接在’[’或’[^’之后

.

小数点可以匹配除了换行符（/n）以外的任意一个字符

/d

可以匹配任何一个 0~9 数字字符

/D

D大写，可以匹配任何一个非数字字符

/s

可以匹配空格、制表符、换页符等空白字符的其中任意一个

/S

S大写，可以匹配任何一个空白字符以外的字符

/w

可以匹配任何一个字母或者数字或者下划线

/W

W大写，可以匹配任何一个字母或者数字或者下划线以外的字符

JavaScript无POSIX格式

C）限定符（重复）

限定符有2种形式，分别为’*’,’+’,’?’与’ {’与’}’来表示

表3 限定符

限定符

特殊意义

*

表达式尽可能的多匹配，最少可以不匹配，相当于 {0, }

+

表达式尽可能的多匹配，至少匹配1次，相当于 {1, }

?

表达式尽可能匹配1次，也可以不匹配，相当于 {0, 1}

{m,n}

表达式尽可能重复n次，至少重复m次："ba{1,3}"可以匹配 "ba"或"baa"或"baaa"

{m}

表达式固定重m次，比如："/w{2}" 相当于 "/w/w"

{m,}

表达式尽可能的多匹配，至少重复m次："/w/d{2,}"可以匹配 "a12","x456"...



在正则中有贪婪与非贪婪之分，默认的情况下，正则是贪婪的

如果要把正则设置为非贪婪有2种方式，一种为设置在原先的限定符加上’?’就行，另一种在设置

举例说明，/.+/ 将匹配"abdddd"中的所有字符，/.+?/ 只将匹配"abdddd"中的第一个a，也就是默认的尽可能多的匹配字符，而非贪婪重复则尽可能上的匹配。



D）选择、分组和引用

选择的语法就是设置’|’，如a|bc，那么要么a或bc都可以匹配，如果(a|b)c则为匹配ac或bc。

如果我们在上例中设置了”()”，那么这就是分组，每个分组都可以被引用，如(a|b)c*(e|f)/1/2，/1与/2就是引用的语法，/1表示引用了(a|b)，/2表示引用(e|f)，以此类推。

这里要说明的是(a|b)c*(e|f)/1/2与(a|b)c*(e|f)(a|b)(e|f)乍一看两者等同，但实际上，前一个不可以匹配acebf，而后一个可以。究其原因就是引用处的配平必须与被引用处一致，此例中与之匹配的可以是aceac。



E）定位符(锚)和前向引用

定位符如下表所示

表4 定位符

限定符

特殊意义

^

匹配输入字符串的开始位置。要匹配 "^" 字符本身

$

匹配输入字符串的结尾位置。要匹配 "$" 字符本身

?

表达式尽可能匹配1次，也可以不匹配，相当于 {0, 1}

/b

匹配单词边界，例如一个/w和/W的位置，或者一个/w与字符串的开始和结尾的位置

/B

和上面的想法，匹配一个非单词边界

如果正则表达式的匹配模式为 MULTILINE 模式，^ 可匹配一行文本的行首，$ 可匹配一行文本的行末。当 /b 被包含于字符集合中时，/b 代表退格符（ASCII码 = 8）。
除了这些预定义的定位符，还可以自定义定位符，这种类型的定位符叫做前向引用(look-ahead anchor)和后向引用(look-behind anchor，JavaScript不支持)。
前向引用使用(?=…)表示正的前向引用，(?!…)表示负的前向引用下面是一个前向引用的例子 /Java(?!Script)([A-Z]/w*)/ 其中(?!Script)匹配后面不跟Script的位置，而(?＝Script)匹配后面是Script的位置。


  <script>
    var re = /^[Jj]ava[Ss]cript/i,
        re2 = /(a|b)c*(e|f)\/1\/2/,
        re21 = /(a|b)c*(e|f)(a|b)(e|f)/, // 这里要说明的是(a|b)c*(e|f)/1/2与(a|b)c*(e|f)(a|b)(e|f)乍一看两者等同，但实际上，前一个不可以匹配acebf，而后一个可以。究其原因就是引用处的配平必须与被引用处一致，此例中与之匹配的可以是aceac。
        str = 'javascript',
        str2 = 'acebf'

    //console.log(re2.test(str2));  //false
    //console.log(re21.test(str2)); //true

    //console.log(/h(ello|appy) hippo/.test('hello there,happy hippo'));

    if(!String.prototype.trim){
      String.prototype.trim = function(){
        //  \s ==>  可以匹配空格、制表符、换页符等空白字符的其中任意一个  下面的例子暂时没有说明哪种方案更优
        // return this.replace(/^\s+/,'').replace(/\s+$/,'');
        // return this.replace(/^\s+/,'').replace(/\s\s*$/,'');
        //return this.replace(/^\s+|\s+$/g,'');  //  ==> 合并了两个简单的正则表达式，并使用 /g 标记来替换所有的匹配项，而不是只替换第一个（当目标字符串同事包含收尾空白时候会匹配两次）
        // 目前比较好的一种方案,但注意不是最佳的，最好的应该是混合式的  参考  http://lib.csdn.net/article/javascript/12512
        return this.replace(/^\s\s*/,'').replace(/\s\s*$/,'');
      }
    };
    //测试新方法 trim
    var trimstr = '\t\n test string '.trim();
    console.log(trimstr == 'test string');


  </script>
</body>
</html>
