<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>DOM的访问和修改</title>
  <style>
    div{
      width: 300px;
      height: 200px;
      overflow: auto;
      border: 1px solid red;
    }
  </style>
</head>
<body>
  <h2>减少DOM的访问次数，把运算留在JS处理</h2>
  <div id="here"></div>
  <div id="there"></div>
  <pre>===========</pre>
  HTML集合是包含DOM节点引用的类数组对象，返回的是集合：
  document.getElementsByName();
  document.getElementsByTagName();
  document.getElementByClassName();

  document.images
  document.links;
  document.forms;

  var elements = document.querySelectorAll('#menu a'); --> CSS选择器作为参数并返回一个Nodelist--包含
  匹配节点的类数组对象，这个方法不会返回HTML集合，因此返回的节点不会对应实时的文档结构。
  <br>
  ===========第二天=========<br>

   <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/createDocumentFragment">document.createDocumentFragment()</a>

   批量修改DOM document.createDocumentFragment(); <br>
   缓存布局信息 <br>
   让元素脱离动画流 避免重排<br>
   少用css::hover  <br>
   事件委托--> 基于：事件是逐层冒泡并能够被父级元素捕获,使用事件代理，只需给外层元素绑定一个处理器，就可以处理在其子元素上触发的所有事件 <br>
   



  <script>
    function innerHTMLLoop(){
      for(var count = 0;count<10000;count++){
        document.getElementById('here').innerHTML += 'a';
        // 每次迭代循环，该元素都会被访问两次，一次读取innerHTML属性值，一次是重写
      }
    };
    // innerHTMLLoop();
    function innerHTMLLoop2(){
      var content = '';
      for(var count = 0;count<10000;count++){
        content += 'b'
      };
      document.getElementById('there').innerHTML += content;
    };
    // innerHTMLLoop2();
  </script>
</body>
</html>
